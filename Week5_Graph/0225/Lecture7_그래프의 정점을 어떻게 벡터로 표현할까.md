#### 1. 정점 표현 학습

1.1 정점 표현 학습이란?

- 정점 표현 학습이란 그래프의 정점들을 벡터의 형태로 표현하는 것입니다
- 정점 표현 학습은 간단히 정점 임베딩(Node Embedding)이라고도 부릅니다
- 정점 임베딩은 벡터 형태의 표현 그 자체를 의미하기도 합니다
- 정점이 표현되는 벡터 공간을 임베딩 공간이라고 부릅시다
- 정점 표현 학습의 입력은 그래프입니다
- 주어진 그래프의 각 정점 𝑢에 대한 임베딩, 즉 벡터 표현 𝒛𝑢가 정점 임베딩의 출력입니다

1.2 정점 표현 학습의 이유

- 정점 임베딩의 결과로, 벡터 형태의 데이터를 위한 도구들을 그래프에도 적용할 수 있습니다
- 기계학습 도구들이 한가지 예시입니다
- 대부분 분류기(로지스틱 회귀분석, 다층 퍼셉트론 등) 그리고 군집 분석 알고리즘(K-Means, DBSCAN 등)은 벡터 형태로 표현된 사례(Instance)들을 입력으로 받습니다
- 그래프의 정점들을 벡터 형태로 표현할 수 있다면, 위의 예시와 같은 대표적인 도구들 뿐 아니라, 최신의 기계 학습도구들을 정점 분류(Node Classification), 군집 분석(Community Detection) 등에 활용할 수 있습니다

1.3 정점 표현 학습의 목표

- 어떤 기준으로 정점을 벡터로 변환해야할까요?
- 그래프에서의 정점간 유사도를 임베딩 공간에서도 “보존”하는 것을 목표로 합니다
- 임베딩 공간에서의 𝑢와 𝑣의 유사도는 둘의 임베딩의 내적 𝒛𝑣⊺𝒛𝑢 = ||𝒛𝑢||⋅||𝒛𝑣||⋅𝒄𝒐𝒔(𝜽)입니다
- 내적은 두 벡터가 클 수록, 그리고 같은 방향을 향할 수록 큰 값을 갖습니다
- 그래프에서 두 정점의 유사도는 어떻게 정의할까요?
  - 이 질문에는 여러가지 답이 있을 수 있습니다
  - 본 강의에서는 대표적인 답을 몇 가지를 설명합니다
- 정리하면, 정점 임베딩은 다음 두 단계로 이루어집니다
  1) 그래프에서의 정점 유사도를 정의하는 단계
  2) 정의한 유사도를 보존하도록 정점 임베딩을 학습하는 단계

#### 2. 인접성 기반 접근법

2.1 인접성 기반 접근법

- 인접성(Adjacency) 기반 접근법에서는 두 정점이 인접할 때 유사하다고 간주합니다
- 두 정점 𝑢와 𝑣가 인접하다는 것은 둘을 직접 연결하는 간선 (𝑢,𝑣)가 있음을 의미합니다
- 인접행렬(Adjacency Matrix) 𝐀의 𝑢행 𝑣열 원소 𝐀𝑢,𝑣는 𝑢와 𝑣가 인접한 경우 1아닌 경우 0입니다
- 인접행렬의 원소 𝐀𝑢,𝑣 를 두 정점 𝑢와 𝑣의 유사도로 가정합니다
- 인접성 기반 접근법의 손실 함수(Loss Function)는 아래와 같습니다
  ![img](https://media.vlpt.us/images/skaurl/post/030b73f6-51d5-431d-9661-b529792b883e/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-02-25%2009.38.06.png)
- 즉, 이 손실 함수가 최소가 되는 정점 임베딩을 찾는 것을 목표로 합니다
- 손실 함수 최소화를 위해서는 (확률적) 경사하강법 등이 사용됩니다

2.2 인접성 기반 접근법의 한계

- 인접성만으로 유사도를 판단하는 것은 한계가 있습니다
  - 빨간색 정점과 파란색 정점은 거리가 3인 반면 초록색 정점과 파란색 정점은 거리가 2입니다
  - 인접성만을 고려할 경우 이러한 사실에 대한 고려 없이, 두 경우의 유사도는 0으로 같습니다
- 인접성만으로 유사도를 판단하는 것은 한계가 있습니다
  - 군집 관점에서는 빨간색 정점과 파란색 정점은 다른 군집에 속하는 반면 초록색 정점과 파란색 정점은 다른 군집에 속합니다
  - 인접성만을 고려할 경우 이러한 사실에 대한 고려 없이, 두 경우의 유사도는 0으로 같습니다

#### 3. 거리/경로/중첩 기반 접근법

3.1 거리 기반 접근법

- 거리 기반 접근법에서는 두 정점 사이의 거리가 충분히 가까운 경우 유사하다고 간주합니다

3.2 경로 기반 접근법

- 경로 기반 접근법에서는 두 정점 사이의 경로가 많을 수록 유사하다고 간주합니다
- 정점 𝑢와 𝑣의 사이의 경로(Path)는 아래 조건을 만족하는 정점들의 순열(Sequence)입니다
  (1) 𝑢에서 시작해서 𝑣에서 끝나야 합니다
  (2) 순열에서 연속된 정점은 간선으로 연결되어 있어야 합니다
- 두 정점 𝑢와 𝑣의 사이의 경로 중 거리가 𝑘인 것은 수는 𝐀𝑢,𝑣^𝑘와 같습니다
- 즉, 인접 행렬 𝐀의 𝑘 제곱의 𝑢행 𝑣열 원소와 같습니다
- 경로 기반 접근법의 손실 함수는 다음과 같습니다
  ![img](https://media.vlpt.us/images/skaurl/post/11fa6e97-bb66-4ac7-9174-7297ba44e09c/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-02-25%2009.42.37.png)

3.3 중첩 기반 접근법

- 중첩 기반 접근법에서는 두 정점이 많은 이웃을 공유할 수록 유사하다고 간주합니다
- 정점 𝑢의 이웃 집합을 𝑁(𝑢) 그리고 정점 𝑣의 이웃 집합을 𝑁(𝑣)라고 하면 두 정점의 공통 이웃 수 𝑆𝑢,𝑣는 다음과 같이 정의 됩니다
  ![img](https://media.vlpt.us/images/skaurl/post/0fe24c1a-1893-4b3e-84dc-227d4d1bafeb/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-02-25%2009.44.08.png)
- 중첩 기반 접근법의 손실 함수는 다음과 같습니다
  ![img](https://media.vlpt.us/images/skaurl/post/90bf092c-01df-4870-94f3-948cac7e919f/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-02-25%2009.44.38.png)
- 공통 이웃 수를 대신 자카드 유사도 혹은 Adamic Adar 점수를 사용할 수도 있습니다
- 자카드 유사도(Jaccard Similarity)는 공통 이웃의 수 대신 비율을 계산하는 방식입니다
  ![img](https://media.vlpt.us/images/skaurl/post/f22b3d99-9037-41db-89a7-8294a5f43134/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-02-25%2009.45.33.png)
- Adamic Adar 점수는 공통 이웃 각각에 가중치를 부여하여 가중합을 계산하는 방식입니다
  ![img](https://media.vlpt.us/images/skaurl/post/1942a7d3-e64a-4d1a-a997-b4d08f3835c9/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-02-25%2009.46.01.png)

#### 4. 임의보행 기반 접근법

- 임의보행 기반 접근법에서는 한 정점에서 시작하여 임의보행을 할 때 다른 정점에 도달할 확률을 유사도로 간주합니다
- 임의보행이란 현재 정점의 이웃 중 하나를 균일한 확률로 선택하는 이동하는 과정을 반복하는 것을 의미합니다
- 임의보행을 사용할 경우 시작 정점 주변의 지역적 정보와 그래프 전역 정보를 모두 고려한다는 장점이 있습니다
- 임의보행 기반 접근법은 세 단계를 거칩니다
  1) 각 정점에서 시작하여 임의보행을 반복 수행합니다
  2) 각 정점에서 시작한 임의보행 중 도달한 정점들의 리스트를 구성합니다. 이 때, 정점 𝑢에서 시작한 임의보행 중 도달한 정점들의 리스트를 𝑁𝑅(𝑢)라고 합시다. 한 정점을 여러 번 도달한 경우, 해당 정점은 𝑁𝑅(𝑢)에 여러 번 포함될 수 있습니다
  3) 다음 손실함수를 최소화하는 임베딩을 학습합니다
  ![img](https://media.vlpt.us/images/skaurl/post/98233eaa-1a76-4f09-80be-5fb0ea433000/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-02-25%2009.49.46.png)
- 어떻게 임베딩으로부터 도달 확률을 추정할까요?
- 정점 𝑢에서 시작한 임의보행이 정점 𝑣에 도달할 확률 𝑃(𝑣|𝑧𝑢)을 다음과 같이 추정합니다
  ![img](https://media.vlpt.us/images/skaurl/post/90bfff0b-8645-4029-b74e-8c0593f8347c/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-02-25%2009.51.00.png)
- 즉 유사도 𝒛𝑣⊺𝒛𝑢가 높을 수록 도달 확률이 높습니다
- 추정한 도달 확률을 사용하여 손실함수를 완성하고 이를 최소화하는 임베딩을 학습합니다
  ![img](https://media.vlpt.us/images/skaurl/post/e0e725ad-6b11-404b-a6dc-06f848439160/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-02-25%2009.51.41.png)

4.2 DeepWalk와 Node2Vec

- 임의보행의 방법에 따라 DeepWalk와 Node2Vec이 구분됩니다
- DeepWalk는 앞서 설명한 기본적인 임의보행을 사용합니다
- 즉, 현재 정점의 이웃 중 하나를 균일한 확률로 선택하는 이동하는 과정을 반복합니다
- Node2Vec은 2차 치우친 임의보행(Second-order Biased Random Walk)을 사용합니다
- 현재 정점(예시에서 𝑣)과 직전에 머물렀던 정점(예시에서 𝑢)을 모두 고려하여 다음 정점을 선택합니다
- 직전 정점의 거리를 기준으로 경우를 구분하여 차등적인 확률을 부여합니다
- Node2Vec에서는 부여하는 확률에 따라서 다른 종류의 임베딩을 얻습니다
- 멀어지는 방향에 높은 확률을 부여한 경우, 정점의 역할(다리 역할, 변두리 정점 등)이 같은 경우 임베딩이 유사합니다
- 가까워지는 방향에 높은 확률을 부여한 경우, 같은 군집(Community)에 속한 경우 임베딩이 유사합니다

4.3 손실 함수 근사

- 임의보행 기법의 손실함수는 계산에 정점의 수의 제곱에 비례하는 시간이 소요됩니다
- 중첩된 합 때문입니다
  ![img](https://media.vlpt.us/images/skaurl/post/0ea679e9-28f3-4fed-b2f5-3b2322004175/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-02-25%2009.54.41.png)
- 정점이 많은 경우, 제곱은 매우 큰 숫자입니다
- 따라서 많은 경우 근사식을 사용합니다
- 모든 정점에 대해서 정규화하는 대신 몇 개의 정점을 뽑아서 비교하는 형태입니다
- 이 때 뽑힌 정점들을 네거티브 샘플이라고 부릅니다
- 연결성에 비례하는 확률로 네거티브 샘플을 뽑으며, 네거티브 샘플이 많을 수록 학습이 더욱 안정적입니다
  ![img](https://media.vlpt.us/images/skaurl/post/ae940736-6348-487a-a5ae-1fcd4e9b2825/%EC%8A%A4%ED%81%AC%EB%A6%B0%EC%83%B7%202021-02-25%2009.56.05.png)

#### 5. 변환식 정점 표현 학습의 한계

5.1 변환식 정점 표현 학습과 귀납식 정점 표현 학습

- 지금까지 소개한 정점 임베딩 방법들을 변환식(Transductive) 방법입니다
- 변환식(Transdctive) 방법은 학습의 결과로 정점의 임베딩 자체를 얻는다는 특성이 있습니다
- 정점을 임베딩으로 변화시키는 함수, 즉 인코더를 얻는 귀납식(Inductive) 방법과 대조됩니다

5.2 변환식 정점 표현 학습의 한계

- 변환식 임베딩 방법은 여러 한계를 갖습니다
  1) 학습이 진행된 이후에 추가된 정점에 대해서는 임베딩을 얻을 수 없습니다
  2) 모든 정점에 대한 임베딩을 미리 계산하여 저장해두어야 합니다
  3) 정점이 속성(Attribute) 정보를 가진 경우에 이를 활용할 수 없습니다
- 대표적인 귀납식 임베딩 방법이 바로 그래프 신경망(Graph Neural Network)입니다

#### 7강 정리

1. 정점 표현 학습

   - 그래프의 정점들을 벡터로 표현하는 것

   - 그래프에서 정점 사이의 유사성을 계산하는 방법에 따라 여러 접근법이 구분됨

2. 인접성 기반 접근법

3. 거리/경로/중첩 기반 접근법

4. 임의보행 기반 접근법
   - 임의보행 방법에 따라 DeepWalk와 Node2Vec가 구분됨

5. 변환식 정점 표현 학습의 한계